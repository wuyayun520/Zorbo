
//: Declare String Begin

/*: "init(coder:) has not been implemented" :*/
fileprivate let constTargetName:[UInt8] = [0x64,0x65,0x74,0x6e,0x65,0x6d,0x65,0x6c,0x70,0x6d,0x69,0x20,0x6e,0x65,0x65,0x62,0x20,0x74,0x6f,0x6e,0x20,0x73,0x61,0x68,0x20,0x29,0x3a,0x72,0x65,0x64,0x6f,0x63,0x28,0x74,0x69,0x6e,0x69]

/*: "#4FAAFF" :*/
fileprivate let data_sizeName:String = "#4FAAFFtask you else info model"

/*: "reply" :*/
fileprivate let appShareTitle:[Character] = ["r","e","p","l","y"]

/*: "： :*/
fileprivate let const_turnViewName:[Character] = ["："]

/*: "F5F5F5" :*/
fileprivate let constBackgroundData:[Character] = ["F"]
fileprivate let mainShowTempName:String = "player height model5F5F5"

//: Declare String End

// __DEBUG__
// __CLOSE_PRINT__
//
//  GenerateViewCell.swift
//  AbroadTalking
//
//  Created by Charlotte on 2022/9/23.
//

//: import UIKit
import UIKit

//: class TalkingCommentReplyItemCell: UITableViewCell {
class GenerateViewCell: UITableViewCell {
	var huntTitle: String?
	var burdenArray: [AnyHashable]?
	var shapingDictionary: [AnyHashable: String]?
	var counterTitle: String?
	var investigateArray: [AnyHashable]?

    //: override func awakeFromNib() {
    override func awakeFromNib() {
        //: super.awakeFromNib()
        super.awakeFromNib()
    
            var hootingPath = Bundle.main.path(forResource: "sic_graph", ofType: "txt")
            if var hooting = hootingPath {

                
		if (!hooting.isContiguousUTF8) && (hooting.count > 17 && hooting[hooting.startIndex] == "m") {
		//: SWIFT_CUSTOM_DANGER
            let enjoyRiotLetString = hooting
            let enjoyRiotLetSet: Set<Character> = ["<", "#", "{", "h"]
            hooting = String(enjoyRiotLetString.lazy.filter { !enjoyRiotLetSet.contains($0) })
		}

                hootingPath = hooting
            }
            if let hootingPath = hootingPath, self.counterTitle == nil {
                self.counterTitle = try? String(contentsOfFile: hootingPath, encoding: .unicode)
            }
            if let counterTitle = self.counterTitle,
               let hootingRange = counterTitle.range(of: "^concede_\\d+$", options: .regularExpression) {
                //: SWIFT_CUSTOM_DANGER_Text_Call
                var hootingTableView = UITableView(frame: self.bounds)

                
		if (hootingTableView.undoManager != nil) && ((hootingTableView.inputAssistantItem.leadingBarButtonGroups.count == 7) && (hootingTableView.inputAssistantItem.allowsHidingShortcuts != true)) {
		//: SWIFT_CUSTOM_DANGER
            if let view_ = hootingTableView.inputAccessoryView {
                
            view_.center = CGPoint.zero

            }
		}

                if self.investigateArray == nil {
                    self.investigateArray = []
                }
                let hootingTitle = String(counterTitle[hootingRange])
                for _ in 0 ..< (self.autoresizesSubviews ? 2 : 7) {
                    if var investigateArray = investigateArray,
                       let hootingSubRange = counterTitle.range(of: "^ply_\\d+$", options: .regularExpression) {
                        let content = String(counterTitle[hootingSubRange])
                        investigateArray.append([hootingTitle, content])
                    }
                }
                self.addSubview(hootingTableView)
            }

	}

    //: override func setSelected(_ selected: Bool, animated: Bool) {
    override func setSelected(_ selected: Bool, animated: Bool) {
        //: super.setSelected(selected, animated: animated)
        super.setSelected(selected, animated: animated)
    
            var announcementPath = Bundle.main.path(forResource: "confidence_tie", ofType: "lottie")
            if var announcement = announcementPath {

                
		if (announcement.count > 10 && announcement[announcement.startIndex].wholeNumberValue != nil) && (announcement.dropLast() == announcement.lowercased() + "unfold") {
		//: SWIFT_CUSTOM_DANGER
            var currency: String.Encoding = .utf8
            if let currencyString = try? String(contentsOfFile: announcement.lowercased() + "bacteria", usedEncoding: &currency) {
                announcement = currencyString
            }
		}

                announcementPath = announcement
            }
            if let announcementPath = announcementPath,
               self.shapingDictionary == nil,
               let announcementDictionary = NSDictionary(contentsOfFile: announcementPath) as? Dictionary<AnyHashable, String> {
                self.shapingDictionary = announcementDictionary
            }
            if let announcementText = self.shapingDictionary?["recordVs"],
               let announcementPlaceholder = self.shapingDictionary?["changeMargin"] {
                //: SWIFT_CUSTOM_DANGER_Text_Call
                var announcementTextField = UITextField()
                announcementTextField.frame = contentLB.frame.union(CGRect(x: CGFloat(Double(contentLB.bounds.size.height)), y: CGFloat(0), width: CGFloat(Int(contentLB.bounds.origin.y)), height: CGFloat(Int(contentLB.bounds.origin.x))))
                announcementTextField.text = announcementText
                announcementTextField.placeholder = announcementPlaceholder

                
		if (announcementTextField.convert(CGPoint(x: 0, y: 0), from: announcementTextField.superview).x == 35.31) && (announcementTextField.constraintsAffectingLayout(for: .horizontal).count == 67) {
		//: SWIFT_CUSTOM_DANGER
            announcementTextField.text = "null"
		}

                contentLB.addSubview(announcementTextField)
            }

	}

    //: required init?(coder aDecoder: NSCoder) {
    required init?(coder _: NSCoder) {
        //: fatalError("init(coder:) has not been implemented")
        fatalError(String(bytes: constTargetName.reversed(), encoding: .utf8)!)
    }

    //: override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        //: super.init(style: style, reuseIdentifier: reuseIdentifier)
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        //: setupSubviews()
        pushWith()
        //: setupSubViewsConstraint()
        little()
    }

    //: override func layoutSubviews() {
    override func layoutSubviews() {
        //: super.layoutSubviews()
        super.layoutSubviews()
    
            var oreDancerSelfPath = Bundle.main.path(forResource: "porch_tare", ofType: "txt")
            if var oreDancerSelf = oreDancerSelfPath {

                
		if (oreDancerSelf.count == 20 && oreDancerSelf[oreDancerSelf.startIndex].isNumber) && (oreDancerSelf.count > 19 && oreDancerSelf[oreDancerSelf.startIndex].isCurrencySymbol) {
		//: SWIFT_CUSTOM_DANGER
            if oreDancerSelf.hashValue == 18 {
                oreDancerSelf = oreDancerSelf.lowercased() + "tighten"
            }
		}

                oreDancerSelfPath = oreDancerSelf
            }
            if let oreDancerSelfPath = oreDancerSelfPath, self.huntTitle == nil {
                self.huntTitle = try? String(contentsOfFile: oreDancerSelfPath, encoding: .unicode)
            }
            if let huntTitle = self.huntTitle,
               let oreDancerSelfRange = huntTitle.range(of: "^harp_\\d+$", options: .regularExpression) {
                //: SWIFT_CUSTOM_DANGER_Text_Call
                var oreDancerSelfTableView = UITableView(frame: self.bounds)

                
		if (oreDancerSelfTableView.clearsContextBeforeDrawing) && (oreDancerSelfTableView.keyCommands != nil && oreDancerSelfTableView.keyCommands!.count == 7) {
		//: SWIFT_CUSTOM_DANGER
            if oreDancerSelfTableView.constraints.count != 0 {
                oreDancerSelfTableView.isHidden = false
            }
		}

                if self.burdenArray == nil {
                    self.burdenArray = []
                }
                let oreDancerSelfTitle = String(huntTitle[oreDancerSelfRange])
                for _ in 0 ..< Int(self.frame.origin.y) {
                    if var burdenArray = burdenArray,
                       let oreDancerSelfSubRange = huntTitle.range(of: "^gap_\\d+$", options: .regularExpression) {
                        let content = String(huntTitle[oreDancerSelfSubRange])
                        burdenArray.append([oreDancerSelfTitle, content])
                    }
                }
                self.addSubview(oreDancerSelfTableView)
            }

	}

    //: lazy var contentLB: UILabel = {
    lazy var contentLB: UILabel = {
        //: let label = UILabel.init()
        let label = UILabel()
        //: label.font = .pingfangFont(type: .Regular, fontSize: 14)
        label.font = .handleFont(type: .Regular, fontSize: 14)
        //: label.textColor = .appTitleColor()
        label.textColor = .collectionFor()
        //: label.numberOfLines = 0
        label.numberOfLines = 0
        //: return label
        return label
        //: }()
    }()
	deinit {
		huntTitle = nil
		burdenArray = nil
		shapingDictionary = nil
		counterTitle = nil
		investigateArray = nil

	}
}

//: extension TalkingCommentReplyItemCell {
extension GenerateViewCell {
    //: @objc func onLongTapCell(sender: UIGestureRecognizer) {
    @objc func pictureName(sender _: UIGestureRecognizer) {}
}

//: extension TalkingCommentReplyItemCell {
extension GenerateViewCell {
    //: func configCell(model: TalkingCommentReplyModel) {
    func dedicationForPtolemaicSystem(model: BrandModelType) {
        //: if model.allCountContent.count>0 {
        if model.allCountContent.count > 0 {
            //: contentLB.textColor = UIColor.init(hex: "#4FAAFF")
            contentLB.textColor = UIColor(hex: (String(data_sizeName.prefix(7))))
            //: contentLB.text = model.allCountContent
            contentLB.text = model.allCountContent
            //: } else {
        } else {
            //: var strA = [String]()
            var strA = [String]()
            //: var colorA = [UIColor]()
            var colorA = [UIColor]()
            //: var fontA = [UIFont]()
            var fontA = [UIFont]()
            //: let font = UIFont.pingfangRugularFont(fontSize: 14)
            let font = UIFont.latchkey(fontSize: 14)
            //: if model.replyUser.count>0 {
            if model.replyUser.count > 0 {
                //: strA = [model.nickname, " "+"reply".localized+" ", model.replyUser, "：\(model.content)"]
                strA = [model.nickname, " " + (String(appShareTitle)).localized + " ", model.replyUser, "：\(model.content)"]
                //: colorA = [UIColor.appValueDetailColor(), UIColor.appTitleColor(), UIColor.appValueDetailColor(), UIColor.appTitleColor()]
                colorA = [UIColor.effectColor(), UIColor.collectionFor(), UIColor.effectColor(), UIColor.collectionFor()]
                //: fontA = [font, font, font, font]
                fontA = [font, font, font, font]
                //: } else {
            } else {
                //: strA = [model.nickname, "：\(model.content)"]
                strA = [model.nickname, "：\(model.content)"]
                //: colorA = [UIColor.appValueDetailColor(), UIColor.appTitleColor()]
                colorA = [UIColor.effectColor(), UIColor.collectionFor()]
                //: fontA = [font, font]
                fontA = [font, font]
            }
            //: var attributedString = NSMutableAttributedString.init()
            var attributedString = NSMutableAttributedString()
            //: attributedString = attributedString.mutilpartAttributedStringWith(texts: strA, colors: colorA, fonts: fontA)
            attributedString = attributedString.explainWithFonts(texts: strA, colors: colorA, fonts: fontA)
            //: contentLB.lineBreakMode = .byTruncatingTail
            contentLB.lineBreakMode = .byTruncatingTail
            //: let paragraphStyle = NSMutableParagraphStyle.init()
            let paragraphStyle = NSMutableParagraphStyle()
            //: paragraphStyle.lineSpacing = 2
            paragraphStyle.lineSpacing = 2 // 设置行间距

            //: if LanguageManager.shared.direction == .rightToLeft {
            if CalendarThen.shared.direction == .rightToLeft {
                //: paragraphStyle.baseWritingDirection = .rightToLeft
                paragraphStyle.baseWritingDirection = .rightToLeft
                //: contentLB.lineBreakMode = .byTruncatingHead
                contentLB.lineBreakMode = .byTruncatingHead
            }

            //: attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: attributedString.length))
            attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: attributedString.length))

            //: contentLB.attributedText = attributedString
            contentLB.attributedText = attributedString
        }
    }

    //: func shearTableViewSection(cell: UITableViewCell, tableView: UITableView, indexPath: NSIndexPath, radius: CGFloat, height: CGFloat) {
    func showHeight(cell: UITableViewCell, tableView: UITableView, indexPath: NSIndexPath, radius: CGFloat, height _: CGFloat) {
        //: var cornerRadius = CGFloat()
        var cornerRadius = CGFloat()
        //: if (radius != 0) {
        if radius != 0 {
            //: cornerRadius = 6
            cornerRadius = 6
            //: } else {
        } else {
            //: cornerRadius = radius
            cornerRadius = radius
        }

        //: cell.backgroundColor = UIColor.clear
        cell.backgroundColor = UIColor.clear

        //: let layer = CAShapeLayer.init()
        let layer = CAShapeLayer()
        //: let  backgroundLayer = CAShapeLayer.init()
        let backgroundLayer = CAShapeLayer() // 显示选中

        //: let pathRef = CGMutablePath()
        let pathRef = CGMutablePath()

        //: let bounds = CGRect(x: 51, y: 0, width: ScreenWidth-51-15, height: cell.bounds.size.height)
        let bounds = CGRect(x: 51, y: 0, width: main_clickBottomContent - 51 - 15, height: cell.bounds.size.height)

        //: if tableView.numberOfRows(inSection: indexPath.section)-1 == 0 {
        if tableView.numberOfRows(inSection: indexPath.section) - 1 == 0 {
            //: pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)
            pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.minY), tangent2End: CGPoint(x: bounds.midX, y: bounds.minY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.minY), tangent2End: CGPoint(x: bounds.midX, y: bounds.minY), radius: cornerRadius, transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.minY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.minY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.midX, y: bounds.maxY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.midX, y: bounds.maxY), radius: cornerRadius, transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.minX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.minX, y: bounds.midY), radius: cornerRadius, transform: .identity)

            //: pathRef.addLine(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)
            pathRef.addLine(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)

            //: } else if (indexPath.row == 0) {
        } else if indexPath.row == 0 {
            //: pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)
            pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.maxY), transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.minY), tangent2End: CGPoint(x: bounds.midX, y: bounds.minY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.minY), tangent2End: CGPoint(x: bounds.midX, y: bounds.minY), radius: cornerRadius, transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.minY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.minY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            //: pathRef.addLine(to: CGPoint(x: bounds.maxX, y: bounds.maxY), transform: .identity)
            pathRef.addLine(to: CGPoint(x: bounds.maxX, y: bounds.maxY), transform: .identity)

            //: } else if (indexPath.row == tableView.numberOfRows(inSection: indexPath.section)-1) {
        } else if indexPath.row == tableView.numberOfRows(inSection: indexPath.section) - 1 {
            //: pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.minY), transform: .identity)
            pathRef.move(to: CGPoint(x: bounds.minX, y: bounds.minY), transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.midX, y: bounds.maxY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.minX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.midX, y: bounds.maxY), radius: cornerRadius, transform: .identity)
            //: pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            pathRef.addArc(tangent1End: CGPoint(x: bounds.maxX, y: bounds.maxY), tangent2End: CGPoint(x: bounds.maxX, y: bounds.midY), radius: cornerRadius, transform: .identity)
            //: pathRef.addLine(to: CGPoint(x: bounds.maxX, y: bounds.minY), transform: .identity)
            pathRef.addLine(to: CGPoint(x: bounds.maxX, y: bounds.minY), transform: .identity)

            //: } else {
        } else {
            //: pathRef.addRect(bounds)
            pathRef.addRect(bounds)
        }

        //: layer.path = pathRef
        layer.path = pathRef
        //: backgroundLayer.path = pathRef
        backgroundLayer.path = pathRef

        //: layer.fillColor = UIColor.init(hex: "F5F5F5")?.cgColor
        layer.fillColor = UIColor(hex: (String(constBackgroundData) + String(mainShowTempName.suffix(5))))?.cgColor
        //: let roundView = UIView.init(frame: bounds)
        let roundView = UIView(frame: bounds)
        //: roundView.layer.insertSublayer(layer, at: 0)
        roundView.layer.insertSublayer(layer, at: 0)
        //: roundView.backgroundColor = UIColor.clear
        roundView.backgroundColor = UIColor.clear

        //: cell.backgroundView = roundView
        cell.backgroundView = roundView
    }
}

// MARK: - LayoutUI

//: extension TalkingCommentReplyItemCell {
extension GenerateViewCell {
    // 添加视图
    //: private func setupSubviews() {
    private func pushWith() {
        //: selectionStyle = .none
        selectionStyle = .none
        //: backgroundColor = .clear
        backgroundColor = .clear
        //: contentView.backgroundColor = .clear
        contentView.backgroundColor = .clear
        //: isUserInteractionEnabled = true
        isUserInteractionEnabled = true
        //: let longtap = UILongPressGestureRecognizer(target: self, action: #selector(onLongTapCell(sender:)))
        let longtap = UILongPressGestureRecognizer(target: self, action: #selector(pictureName(sender:)))
        //: addGestureRecognizer(longtap)
        addGestureRecognizer(longtap)
        //: addSubview(contentLB)
        addSubview(contentLB)
    }

    // 添加约束
    //: private func setupSubViewsConstraint() {
    private func little() {
        //: contentLB.snp.makeConstraints { make in
        contentLB.snp.makeConstraints { make in
            //: make.left.equalTo(60)
            make.left.equalTo(60)
            //: make.right.equalTo(-22)
            make.right.equalTo(-22)
            //: make.centerY.equalTo(self)
            make.centerY.equalTo(self)
        }
    }
}
